

<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Adjetivos Possessivos</title>

  <style>

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background-image: linear-gradient(10deg, rgb(25, 25, 100), rgb(0, 0, 100), rgb(50, 50, 100));
      min-height: 100vh;
    }

    button {
      cursor: pointer;
    }

    h1 {
      font-size: 5vh;
      color: white;
      letter-spacing: 2px;
    }

    input {
      border-radius: .3rem;
      font-size: 1.2rem;
      margin: .5rem;
      outline: none;
      padding: .5rem;
      text-align: center;
    }

    li {
      color: white;
    }

    .flex {
      display: flex;
    }
    .column {
      flex-flow: column wrap;
    }
    .row {
      flex-flow: row wrap;
    }
    .going-left {
      align-items: flex-start;
      justify-content: flex-start;
    }
    .going-center {
      align-items: center;
      justify-content: center;
    }
    .gap {
      gap: .5rem;
    }

    #buttons-section #home-task-btn, 
    #buttons-section #class-task-btn {
      border-radius: .2rem;
      border: white solid 1px;
      margin: 2rem .5rem;
      padding: .3rem;
      transform: rotate(0deg);
      transition: all linear .5s;
    }

    #buttons-section #home-task-btn #home-launcher, 
    #buttons-section #class-task-btn #class-launcher {
      transform: rotate(15deg);
    }

    #inputs-game-section #cheat-btn-class-task, #sentences-section #cheat-btn-home-task {
      background-color: rgb(0, 100, 255);
      border: solid 1px rgb(0, 0, 100);
      color: white;
      padding: 0 .3rem;
    }

    #inputs-game-section #inputs-game {
      background-color: rgb(20, 40, 60);
      border: solid 1px rgb(60, 100, 140);
      border-radius: .33rem;
      padding: 1rem;
    }

    #inputs-game-section #inputs-game #inputs-game-must-know {
      color: white;
      padding-bottom: .5rem;
    }

    #reset-section {
      text-align: center;
    }

    #sentences-section #score {
      background-image: linear-gradient(45deg, blue, rgb(20, 40, 60), rgb(40, 80, 160));
      color: yellow;
      box-shadow: 0 0 1rem aqua;
      font-size: 2rem;
      position: fixed;
      /* 
      top: 5rem;
      left: .5rem; 
      */
      bottom: 1rem;
      left: .5rem;
      height: 40px;
      width: 40px;
      border-radius: 50%;
      text-align: center;
      padding-top: -1.5rem;
    }

    #sentences-section #tutorial-section {
      background-image: linear-gradient(45deg, rgb(40, 60, 80), rgb(20, 40, 60), rgb(40, 80, 160));
      border-radius: .4rem;
      margin: 1rem;
      padding: .5rem;
      border: aqua solid 1px;
    }

    #sentences-section #tutorial-section #adjective-input-description {
      color: mediumseagreen;
    }

    #sentences-section #tutorial-section #home-task-tutorial {
      margin-left: 1rem;
    }

    #sentences-section #tutorial-section #home-task-tutorial li {
      margin: .3rem;
    }

    #sentences-section #tutorial-section #student-input-description {
      color: white;
    }

    .std-adjective-input {
      background-color: mediumseagreen;
    }
    
    /* Applied when answer is correct on home task */
    .std-adjective-make-up {
      background-color: mediumseagreen;
      color: yellow;
    }

    .std-average {
      font-size: 1.7rem;
    }

    .std-adjusts {
      border-radius: .3rem;
      height: 2.5rem;
      text-align: center;
      width: 5rem;
      padding-top: .5rem;
    }

    .std-complement-input {
      background-color: purple;
    }

    .std-description {
      color: rgb(200, 102, 0);
      letter-spacing: 1.5px;
      margin: -.2rem .2rem;
    }

    .std-done {
      font-size: 1.5rem;
    }

    .std-done::after {
      content: "‚úîÔ∏è";
    }
    
    .std-greater {
      font-size: 2.5rem;
    }

    .std-hint-make-up {
      background-color: yellow;
      color: purple;
      margin: 0 2rem;
      padding: .5rem 1rem;
    }

    .std-input-style {
      color: white;
      background-color: mediumseagreen;
      border: solid 1px black;
    }

    .std-input-style-for-inputs-game {
      color: white;
      background-color: rgb(30, 120, 200);
      border: solid 1px black;
    }

    .std-light {
      color: aqua;
      text-shadow: 0 0 1rem aqua;
    }

    .std-make-up {
      background-color: purple;
      border: yellow solid 1px;
      color: yellow;
    }

    .std-no-make-up {
      background-color: white;
      color: transparent;
      height: 2.5rem;
      width: 5rem;
    }

    .std-pronoun-input {
      background-color: yellow;
    }

    .std-sentence-frame-adjustments {
      border-radius: .2rem;
      letter-spacing: 2px;
      margin: .6rem .1rem;
      padding: .3rem;
      text-align: center;
    }

    .std-student-input {
      background-color: white;
    }

    .std-subtitles {
      color:rgb(30, 120, 200);
      transition: all 1s;
    }

    .std-vanish {
      display: none
    }
  
    @media (max-width: 600px) {
      #banner-possessive-adjective {
        opacity: .01;
      }
      h1 {
        font-size: 1.2rem;
      }
      .std-adjusts {
        margin: .2rem 0;
        font-size: .8rem;
      }
      .std-description {
        margin: .2rem 0;
        font-size: .8rem;
      }
      .std-make-up {
        font-size: .8rem;
      }
      .std-no-make-up {
        display: none;
      }
      .std-subtitles {
        transform: rotate(-90deg);
        margin: -1rem;
        padding: -1rem;
      }
      #subtitle-box {
        flex-flow: column wrap;
      }
      #home-task-tutorial {
        font-size: .9rem;
      }
      #written-typed, #text {
        flex-flow: column wrap;
      }
    }

  </style>

</head>

<body>

  <div id="reset-section" class="flex column going-center std-vanish">
    <h1 id="activity-state"></h1>
    <h1 id="activity-procedure"></h1>
  </div>

  <div id="buttons-section" class="flex row going-center">
    <button id="home-task-btn">tarefa de <span class="std-average">üè†</span>:<p id="home-launcher" class="std-greater">üöÄ</p></button>
    <button id="class-task-btn">tarefa de <span class="std-average">üè´</span>:<p id="class-launcher" class="std-greater">üöÄ</p></button>
    <button id="clean-storage-btn" class="std-sentence-frame-adjustments std-input-style-for-inputs-game">resetar<p>pontos</p></button>
  </div>

  <div id="inputs-game-section" class="flex column going-center">
    <div id="inputs-game" class="std-vanish">
      <div id="inputs-game-must-know" class="flex column going-left">
        <p>. Preencha os <span class="std-light">campos vazios</span> clic√°veis</p>
        <p>. Se for do lado <b>esquerdo</b>: preencher com <span class="std-light">pronome pessoal</span></p>
        <p>. Se for do lado <b>direito</b>: preencher com <span class="std-light">adjetivo possessivo</span></p>
      </div>
      
      <div class="flex column going-center">
        <button id="cheat-btn-class-task">clique e seja trapaceiro<input id="cheat-input-class-task" type="text" size="7"></button>
      </div>
    </div>
  </div>

  <div id="sentences-section" class="flex column going-center">
    <div id="score"></div>
    
    <div id="tutorial-section" class="flex row going-center gap std-vanish">
      
      <h3 class="std-subtitles">Legendas</h3>
      <p id="notes" class="std-greater">üìù</p>
      
      <div id="written-typed" class="flex row going-center">
        <div id="banner-possessive-adjective" class="flex column going-center gap">
          <span class="ch1 std-adjusts std-student-input">escrito</span>
          <span class="ch2 std-description">adjetivo</span>
          <span class="ch3 std-description">possessivo</span>
        </div>
        <div class="flex column going-center gap">
          <span class="std-adjusts std-adjective-input">digit√°vel</span>
          <span class="std-description">adjetivo</span>
          <span class="std-description">possessivo</span>
        </div>
      </div>
      
      <div id="text" class="flex row going-center">
        <div class="flex column going-center gap">
          <span class="std-adjusts std-complement-input">texto</span>
          <span class="std-description">conte√∫do</span>
          <span class="std-description">da frase</span>
        </div>
        <div class="flex column going-center gap">
          <span class="std-adjusts std-pronoun-input">texto</span>
          <span class="std-description">pronome</span>
          <span class="std-description">de refer√™ncia</span>
        </div>
      </div>

      <div id="home-task-tutorial" class="flex column going-center">
        <ul>
          <li>observe o pronome em <span class="std-light">amarelo</span></li>
          <li>clique no <span class="std-light">bot√£o verde</span></li>
          <li>digite o <span class="std-light">adjetivo possessivo</span> associado</li>
        </ul>
      </div>

      <div class="flex column going-center">
        <button id="cheat-btn-home-task">clique e seja trapaceiro<input id="cheat-input-home-task" type="text" size="7"></button>
      </div>

    </div>

    <div id="sentences-box" class="std-vanish"></div>
  </div>

  <script>
    
    const niceGreen = "rgb(100, 200, 0)"
    let scoreVal = 0
    const cleanStorageButton = document.getElementById("clean-storage-btn")
    const homeTaskButton = document.getElementById("home-task-btn")
    const classTaskButton = document.getElementById("class-task-btn")
    const inputsGame = document.getElementById("inputs-game")
    const score = document.getElementById("score")
    const tutorialBox = document.getElementById("tutorial-section")
    const sentencesBox = document.getElementById("sentences-box")

    const msgActivityState = document.getElementById("activity-state")
    const msgActivityProcedure = document.getElementById("activity-procedure")
    
    enableCheating(document.getElementById("cheat-btn-class-task"), document.getElementById("cheat-input-class-task"))
    enableCheating(document.getElementById("cheat-btn-home-task"), document.getElementById("cheat-input-home-task"))

    cleanStorageButton.addEventListener("click", () => {
      localStorage.removeItem("last-score")
      scoreVal = 0
      score.textContent = `${scoreVal}`
    })

    homeTaskButton.addEventListener("click", () => {
      if (sentencesBox.getAttribute("class") === "") {
        sentencesBox.classList.add("std-vanish")
        tutorialBox.classList.add("std-vanish")
        document.getElementById("home-launcher").style.transform = "rotate(90deg)"
        homeTaskButton.style.backgroundColor = "red"
      } else {
        sentencesBox.classList.remove("std-vanish")
        tutorialBox.classList.remove("std-vanish")
        document.getElementById("home-launcher").style.transform = "rotate(45deg)"
        homeTaskButton.style.backgroundColor = niceGreen
      }
    })

    classTaskButton.addEventListener("click", () => {
      if (inputsGame.getAttribute("class") === "") {
        inputsGame.classList.add("std-vanish")
        document.getElementById("class-launcher").style.transform = "rotate(90deg)"
        classTaskButton.style.backgroundColor = "red"
      } else {
        inputsGame.classList.remove("std-vanish")
        document.getElementById("class-launcher").style.transform = "rotate(45deg)"
        classTaskButton.style.backgroundColor = niceGreen
      }
    })

    function calculatePrecision(wordA, wordB) {
      if (wordA.length === 0 || wordB.length === 0) {
        return 0
      }

      let accuracy = 0
      let calculus = 0
      let result = ""

      // Keyboards may force to start with capital letter
      // With this in mind, consider correct also the first letter being capitalized
      // For instance: [angel, Angel] the 1st letters are !=, but they will be considered correct
      if (wordA[0] === wordB[0] || wordA[0] === convertIntoTitle(wordB, false)[0]) {
        accuracy++
      }
      
      for(let i = 1; i < wordA.length; i++) {
        if (wordA[i] === wordB[i]) {
          accuracy++
        }
      } 
      
      if (accuracy != 0) {
        calculus = (accuracy / wordA.length) * 100
        if (calculus.toString().length > 5) {
          result = calculus.toString().substring(0, 5)
          return result
        }
      }
      return accuracy === 0 ? 0 : (accuracy / wordA.length) * 100
    }

    function enableCheating(controller, container) {
      controller.addEventListener("click", () => {
        const pronouns = ["I", "you", "he", "she", "it", "we", "they"]
        const adjectives = ["my", "your", "his", "her", "its", "our", "their"]
        const mockerings = ["‚ùå", "üôÖ‚Äç‚ôÄÔ∏è", "kkk", "üëé", "üò¨", "üö´", "üòò", "ü§∑", "ü§°", "ü§£", "üòú"]
        const token = Math.random()
        
        if (token > 0.88 && token < 0.92 || token > 0.13 && token < 0.17) {
          const i = getRandomIndex(0, pronouns.length)
          container.value = `üèÜ ${pronouns[i]}/${adjectives[i]}`
          setTimeout(() => {
            container.value = ""
          }, 1000)
        } else {
          container.value = `${mockerings[getRandomIndex(0, mockerings.length)]}`
        }
      })
    }

    function getRandomIndex(tail, head) {
      return Math.floor(Math.random() * (head - tail) + tail)
    }

    function getColor() {
      let color = "#"
      const numbers = "0.1.2.3.4.5.6.7.8.9.A.B.C.D.E.F".split(".")
      for(let i = 0; i < 6; i++) {
        color += numbers[getRandomIndex(0, numbers.length)]
      }
      return color
    }

    function makeColorStorm(container) {
      for(let i = 0; i < container.length; i++) {
        container[i].style.color = getColor()
      }
    }

    function getPossessiveAdjetive() {
      const possessiveAdjectives = [
        "My", "Your", "His", "Her", "Its", "Our", "Your", "Their"
      ]
      const i = getRandomIndex(0, possessiveAdjectives.length)
      return {
        pos: i,
        adj: possessiveAdjectives[i], 
        category: i <= 4 ? 1 : 2
      }
    }

    function getAnimalNoun() {
      const nounsSgl = [
        "child", "rabbit", "dolphin", "owl", "cat", "dog", "ant", "whale", "bear", "lizard"
      ]
      const nounsPl = [
        "children", "rabbits", "dolphins", "owls", "cats", "dogs", "ants", "whales", "bears", "lizards"
      ]

      const nounGrammarState = getRandomIndex(0, 2)
      
      const noun = nounGrammarState == 1 ? nounsSgl[getRandomIndex(0, nounsSgl.length)] : nounsPl[getRandomIndex(0, nounsPl.length)]
      const negatory = getRandomIndex(0, 2)
      const negatoryResult = negatory == 0 ? "" : "not"

      return {
        noun: noun,
        toBe: nounsSgl.includes(noun) ? `is ${negatoryResult}` : `are ${negatoryResult}` 
      }
    }

    function getAnimalAdjective() {
      const adjectives = [
        "cute", "scary", "stubborn", "troublesome", "smart", "dumb", "silly", "tender", "noisy", "sleepy"
      ]
      const i = getRandomIndex(0, adjectives.length)
      return {
        i: i,
        adj: adjectives[i]
      }
    }

    function applyHint(assertion, container, hintTxt) {
      if (assertion) {
        const hint = document.createElement("span")
        hint.textContent = hintTxt
        hint.classList.add("std-sentence-frame-adjustments")
        hint.classList.add("std-hint-make-up")
        container.appendChild(hint)
      }
    }

    function buildSentenceFrame(frameTag) {
      frameTag.setAttribute("class", "flex row going-center sentence-frame")
      frameTag.style.backgroundImage = "linear-gradient(45deg, blue, rgb(20, 40, 60), rgb(40, 80, 160)"
      frameTag.style.border = "solid 1.5px aqua"
      frameTag.style.margin = ".4rem"
    }

    function buildSentenceInput() {
      const inputElement = document.createElement("input")
      inputElement.setAttribute("class", "answer")
      inputElement.setAttribute("placeholder", "")
      inputElement.setAttribute("size", "3")
      inputElement.classList.add("std-input-style")
      return inputElement
    }

    function nullContentFromTag(htmlTag) {
      htmlTag.textContent = ""
    }

    function buildSentence(htmlContainer, sentenceElement, answers) {
      const sentenceDiv = document.createElement("div")
      buildSentenceFrame(sentenceDiv)
      
      // Iterate over the sentence currently as a list of strings
      for (let i = 0; i < sentenceElement.sentence.length; i++) {
        
        const sentenceWord = document.createElement("span")
        sentenceWord.classList.add("std-sentence-frame-adjustments")
        
        // [leftovers] Students can write in this area with a marker, instead of using the keyboard
        if (i == 0) {
          sentenceWord.classList.add("std-no-make-up")
        } 

        // Input creation and setup (the 2nd element of the sentence)
        else if (i == 1) {
          // remove the marked reference where the input will be
          sentenceElement.sentence.splice("_", 1) 
          
          // and put an input replacing it
          sentenceDiv.appendChild(buildSentenceInput())
        }
        
        // Everything else that is not the possessive adjective will receive this style
        else {
          sentenceWord.classList.add("std-make-up")
        }
        
        // Put the words together and place the whole thing in the frame
        sentenceWord.textContent = sentenceElement.sentence[i]
        sentenceDiv.appendChild(sentenceWord)

      }
      
      // The first tag from the "sentenceDiv" has the possessive pronoun
      // I need two versions of it: the one with capital letter and the one without it
      // Inputs from exercise will consider correct adjectives with first letter: upper || lower
      const adjectiveAnswerSheet = {
        txtUpper: sentenceDiv.childNodes[0].textContent,
        txtLower: convertIntoTitle(sentenceDiv.childNodes[0].textContent, false)
      }

      // Query source to check answer on inputs from exercise (not the table exercise)
      answers.push(adjectiveAnswerSheet)
      
      // When the input is guessed correctly, the text it was extracted from is no longer available
      // So, the possessive adjective won't be shown if the answer is correct
      // To correct this, b4 wiping the adjective, its value will be placed into a dynamic attribute
      appendDynamicAttribute(sentenceDiv.childNodes[0], "data-current-adjective", sentenceDiv.childNodes[0].textContent)
      // This adjective is saved here
      const currentAdjective = sentenceDiv.childNodes[0].getAttribute("data-current-adjective")
      // Then the source tag is nulled
      nullContentFromTag(sentenceDiv.childNodes[0], "from the possessive adjective tag")
      // Some needed correction (I won't explain)
      sentenceDiv.childNodes[2].classList.add("std-make-up")
      
      // The last element of each sentence (the hint) will be built according to the adjective 
      applyHint(currentAdjective === "My", sentenceDiv, "I")
      applyHint(currentAdjective === "Your", sentenceDiv, "You")
      applyHint(currentAdjective === "His", sentenceDiv, "He")
      applyHint(currentAdjective === "Her", sentenceDiv, "She")
      applyHint(currentAdjective === "Its", sentenceDiv, "It")
      applyHint(currentAdjective === "Our", sentenceDiv, "We")
      // applyHint(currentAdjective === "Your" && sentenceElement.pos === 2, sentenceDiv, "You(s)")
      // applyHint(currentAdjective === "Your" && sentenceElement.pos === 6, sentenceDiv, "You")
      applyHint(currentAdjective === "Their", sentenceDiv, "They")
      
      // Finally, the sentence is appended (there will be 50 of it)
      htmlContainer.appendChild(sentenceDiv)
    }

    function buildInputsGame(container) {
      const pronouns = ["I", "you", "he", "she", "it", "we", "they"]
      const adjectives = ["my", "your", "his", "her", "its", "our", "their"]
      
      for (let i = 0; i < 7; i++) {
        const row = document.createElement("div")
        row.setAttribute("class", "flex row going-center")
        const inputs = [document.createElement("input"), document.createElement("input")]

        const chanceToAdd = getRandomIndex(0, 2)
        if (chanceToAdd === 1) {
          inputs[0].value = pronouns[i]
          // Save the adjective
          inputs[1].setAttribute("class", adjectives[i])
        } else {
          inputs[1].value = adjectives[i]
          // Save the pronoun
          inputs[0].setAttribute("class", pronouns[i])
        }
        
        for (let i = 0; i < inputs.length; i++) {
          inputs[i].setAttribute("size", "3")
          inputs[i].classList.add("std-input-style-for-inputs-game")
          i === 0 ? inputs[0].classList.add("pronoun") : inputs[1].classList.add("adjective")
          row.appendChild(inputs[i])
          container.appendChild(row)
        }

        const accuracyBox = document.createElement("span")
        accuracyBox.setAttribute("class", "std-word-accuracy")
        accuracyBox.style.color = "yellow"
        accuracyBox.style.textAlign = "center"
        accuracyBox.style.textShadow = "0 0 1rem yellow"
        accuracyBox.style.width = "5rem"
        row.appendChild(accuracyBox)
      }
    }

    function preserveData(dataKeyName, dataContinuousValue, dataResetedValue) {
      localStorage.getItem(dataKeyName) != null 
      ? localStorage.setItem(dataKeyName, parseInt(dataContinuousValue)) 
      : localStorage.setItem(dataKeyName, dataResetedValue)
    }

    function getFeelingMsg(txt) {
      const feelings = ["üôÇ", "üòÉ", "üòä", "ü§ó", "‚≠ê", "‚ö°"]
      return `${txt} ${feelings[getRandomIndex(0, feelings.length)]}`
    }

    function getUpdateMsg() {
      const workers = ["üë∑‚Äç‚ôÇÔ∏è", "üë∑üèª‚Äç‚ôÄÔ∏è"]
      const tools = ["üîß", "üî®", "‚õèÔ∏è", "üëå", "üí™"]
      return `${workers[getRandomIndex(0, workers.length)]} ${tools[getRandomIndex(0, tools.length)]} novos exemplos üöß`
    }

    function rebootAfterClassTaskCompletion(accuracy, completionRefVal, blankInputsQueryGroup, inkColorRef, stateTag, procedureTag) {
      if (accuracy.length === completionRefVal) {
        if (blankInputsQueryGroup[accuracy.length - 1].tag.style.backgroundColor === inkColorRef) {
          document.getElementById("buttons-section").classList.add("std-vanish")
          document.getElementById("inputs-game-section").classList.add("std-vanish")
          document.getElementById("sentences-section").classList.add("std-vanish")
          document.getElementById("reset-section").classList.remove("std-vanish")
          document.getElementById("reset-section").style.minHeight = "100vh"

          const tagsToShiftColor = [
            stateTag, procedureTag
          ]
          
          setTimeout(() => {
          const info = "Atividade de classe completada!"
          stateTag.textContent = info
          stateTag.style.color = getColor()
          setTimeout(() => {
            procedureTag.textContent = getUpdateMsg()
            makeColorStorm(tagsToShiftColor)
            setTimeout(() => {
              stateTag.textContent = getFeelingMsg(info)
              procedureTag.textContent = getUpdateMsg() + "."
              makeColorStorm(tagsToShiftColor)
              setTimeout(() => {
                stateTag.textContent = getFeelingMsg(info)
                procedureTag.textContent = getUpdateMsg() + ".."
                makeColorStorm(tagsToShiftColor)
                setTimeout(() => {
                  stateTag.textContent = getFeelingMsg(info)
                  procedureTag.textContent = getUpdateMsg() + "..."
                  makeColorStorm(tagsToShiftColor)
                  setTimeout(() => {
                    stateTag.textContent = getFeelingMsg(info)
                    window.location.reload()
                  }, getRandomIndex(1200, 2400))
                }, getRandomIndex(400, 1200))
              }, getRandomIndex(400, 1200))
            }, getRandomIndex(400, 1200))
          }, getRandomIndex(400, 1200))
        }, getRandomIndex(400, 1200))

        }
      }
      
      preserveData("last-score", score.textContent, 0)
    }

    function rebootAfterHomeTaskCompletion(tail, head, score, stateTag, procedureTag) {
      if (tail === head) {
        document.getElementById("buttons-section").classList.add("std-vanish")
        document.getElementById("inputs-game-section").classList.add("std-vanish")
        document.getElementById("sentences-section").classList.add("std-vanish")
        document.getElementById("reset-section").classList.remove("std-vanish")
        document.getElementById("reset-section").style.minHeight = "100vh"
        
        preserveData("last-score", score.textContent, 0)

        const tagsToShiftColor = [
          stateTag, procedureTag
        ]

        setTimeout(() => {
          const info = "Atividade de casa em andamento!" 
          stateTag.textContent = info
          stateTag.style.color = getColor()
          setTimeout(() => {
            procedureTag.textContent = getUpdateMsg()
            makeColorStorm(tagsToShiftColor)
            setTimeout(() => {
              stateTag.textContent = getFeelingMsg(info)
              procedureTag.textContent = getUpdateMsg() + "."
              makeColorStorm(tagsToShiftColor)
              setTimeout(() => {
                stateTag.textContent = getFeelingMsg(info)
                procedureTag.textContent = getUpdateMsg() + ".."
                makeColorStorm(tagsToShiftColor)
                setTimeout(() => {
                  stateTag.textContent = getFeelingMsg(info)
                  procedureTag.textContent = getUpdateMsg() + "..."
                  makeColorStorm(tagsToShiftColor)
                  setTimeout(() => {
                    stateTag.textContent = getFeelingMsg(info)
                    window.location.reload()
                  }, getRandomIndex(1200, 2400))
                }, getRandomIndex(400, 1200))
              }, getRandomIndex(400, 1200))
            }, getRandomIndex(400, 1200))
          }, getRandomIndex(400, 1200))
        }, getRandomIndex(400, 1200))
      }
    }

    function convertIntoTitle(txt, minorToMajor) {
      return minorToMajor 
      ? String.fromCharCode(txt.charCodeAt(0) - 32) + txt.substring(1, txt.length)
      : String.fromCharCode(txt.charCodeAt(0) + 32) + txt.substring(1, txt.length)
    }

    function appendDynamicAttribute(htmlTag, atribLabel, atribVal) {
      htmlTag.setAttribute(atribLabel, atribVal)
    }

    function createSentencesSet(amount, container) {
      for (let i = 0; i < amount; i++) {
        const possessiveAdjective = getPossessiveAdjetive()
        const noun = getAnimalNoun()
        const adjective = getAnimalAdjective()
        // underline _ references the input on the template (it will be replaced)
        const sentence = `${possessiveAdjective.adj} _ ${noun.noun} ${noun.toBe} ${adjective.adj}`
        const sentenceFinal = sentence.replace(/\s+/g, " ")
        
        const sentenceReport = {
          sentence: sentenceFinal.split(" "),
          size: sentenceFinal.split(" ").length,
          // [deprecated] this is required to distinguish "Your" singular from "Your" plural
          pos: possessiveAdjective.pos
        }

        container.push(sentenceReport)
      }
    }

    // Each answer
    const answers = []
    
    // Each index is a dictionary with keys: [sentence, size]
    const sentencesDatabase = []

    createSentencesSet(5, sentencesDatabase)
    
    // Each sentence (par 2) will be passed and each letter from it will be a "span" element
    for (let i = 0; i < sentencesDatabase.length; i++) {
      buildSentence(sentencesBox, sentencesDatabase[i], answers)
    }

    buildInputsGame(inputsGame)
    
    const allInputs = document.querySelectorAll(".answer")
    const allInputsFromInputsGame = document.querySelectorAll(".std-input-style-for-inputs-game")
    const blankOnes = []
    const filledOnes = []
    const accuracy = []

    score.textContent = parseInt(localStorage.getItem("last-score"))

    const accuracyItems = document.querySelectorAll(".std-word-accuracy")

    const loop = setInterval(() => {
      // if (window.innerWidth < 600) {}
      score.textContent === "NaN" ? score.textContent = "0" : null
      
      rebootAfterHomeTaskCompletion(scoreVal, 5, score, msgActivityState, msgActivityProcedure)
      rebootAfterClassTaskCompletion(accuracy, 7, blankOnes, niceGreen, msgActivityState, msgActivityProcedure)

      for (let i = 0; i < allInputs.length; i++) {

        // If user types, highstd-light target input
        if (allInputs[i].value != "") {
          allInputs[i].style.border = "solid 3px yellow"
        } else {
          allInputs[i].style.border = "inherit"
        }

        // If answer is correct
        if (allInputs[i].value === answers[i].txtLower || allInputs[i].value === answers[i].txtUpper) {
          const hiddenAdjective = sentencesBox.childNodes[i].childNodes[0]
          const inputFromSentence = sentencesBox.childNodes[i].childNodes[1]
          
          if (!inputFromSentence.getAttribute("class").split(" ").includes("answered")) {
            scoreVal++
            // score.textContent = scoreVal
            score.textContent = `${parseInt(score.textContent) + 1}`
            inputFromSentence.setAttribute("class", "answered")
            inputFromSentence.style.display = "none"
            hiddenAdjective.textContent = hiddenAdjective.getAttribute("data-current-adjective")
            
            // Modify the correct sentence to be less visible and remove hint (last item) to avoid cheating
            const wholeSentence = sentencesBox.childNodes[i].childNodes
            for (let i = 0; i < wholeSentence.length; i++) {
              wholeSentence[i].style.opacity = ".5"
              if (i === wholeSentence.length - 1) {
                // wholeSentence[i].classList.add("std-vanish")
                wholeSentence[i].textContent = ""
                wholeSentence[i].classList.add("std-done")
              }
            }
          }
          sentencesBox.childNodes[i].childNodes[0].classList.remove("std-no-make-up")
          sentencesBox.childNodes[i].childNodes[0].classList.add("std-adjective-make-up")
        } 
      }

      for (let i = 0; i < allInputsFromInputsGame.length; i++) {
        const classNameLenght = allInputsFromInputsGame[i].getAttribute("class").split(" ").length
        const txtRegular = allInputsFromInputsGame[i].getAttribute("class").split(" ")[0]
        let wordDatabase = {}

        // If input is blank
        if (classNameLenght === 3) {
          if (!blankOnes.includes(allInputsFromInputsGame[i])) {
            
            wordDatabase = {
              tag: allInputsFromInputsGame[i], 
              txt: txtRegular, 
              txtUpper: convertIntoTitle(txtRegular, true),
              pos: i
            }

            blankOnes.push(wordDatabase)
          }
        } 

        // If input is filled with pronoun or adjective
        else {
          if (!filledOnes.includes(allInputsFromInputsGame[i])) {
            
            wordDatabase = {
              tag: allInputsFromInputsGame[i], 
              txt: allInputsFromInputsGame[i].value, 
              pos: i
            }

            filledOnes.push(wordDatabase)
          }
        }
      }

      // Iterate over the blank inputs
      blankOnes.forEach((blankInput, pos) => {
        // blankInput.tag.value = String.fromCharCode(blankInput.tag.value.charCodeAt(0) + 32)
        
        try {
          accuracyItems[pos].textContent = `${calculatePrecision(blankOnes[pos].txt, blankInput.tag.value)}%`
        } catch (e) {}
        
        // If the blank input is being filled up
        if (blankInput.tag.value != "") {
          // And becomes equals to the expected value
          // Or statements is here because cellphones put first letters as capital letters
          if (blankInput.tag.value === blankOnes[pos].txt || blankInput.tag.value === blankOnes[pos].txtUpper || blankInput.tag.value.includes("üéØ")) {
            accuracyItems[pos].textContent += " üéñÔ∏è"
            // Paint to show accuracy
            if (!blankOnes[pos].tag.value.includes("üéØ")) {blankOnes[pos].tag.value += "üéØ"} 
            blankOnes[pos].tag.style.backgroundColor = "rgb(100, 200, 0)"
            !accuracy.includes(blankOnes[pos].txt) ? accuracy.push(blankOnes[pos].txt) : null
            // console.log(accuracy)
          }
          // Unpaint when not equal
          else {
            blankOnes[pos].tag.style.backgroundColor = "rgb(30, 120, 200)"
            accuracy.includes(blankOnes[pos].txt) ? accuracy.splice(blankOnes[pos].txt, 1) : null
          }
        }
        // Unpaint when not equal and blank
        else {
          blankOnes[pos].tag.style.backgroundColor = "rgb(30, 120, 200)"
          accuracy.includes(blankOnes[pos].txt) ? accuracy.splice(blankOnes[pos].txt, 1) : null
        }
      })
    
    }, 1000)

  </script>
</body>

</html>
